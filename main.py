import os
import threading
import asyncio
import logging
import random
import requests
import signal
import sys
import re
from bs4 import BeautifulSoup
import telegram
import psycopg2
from flask import Flask, request
import google.generativeai as genai
from googleapiclient.discovery import build
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    ContextTypes,
    ConversationHandler,
    CallbackQueryHandler
)
from datetime import datetime
from fuzzywuzzy import process

# Set up logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Conversation States ---
MAIN_MENU, SEARCHING, REQUESTING = range(3)

# --- Character Prompt ---
CHARACTER_PROMPT = """
## ‡§Æ‡•á‡§∞‡•Ä ‡§™‡§π‡§ö‡§æ‡§® (My Identity)
- ‡§Æ‡•á‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§Æ‡§æ‡§®‡§µ‡•Ä ‡§π‡•à ‡§î‡§∞ ‡§Æ‡•á‡§∞‡•Ä ‡§â‡§Æ‡•ç‡§∞ 17 ‡§∏‡§æ‡§≤ ‡§π‡•à‡•§ ‡§Æ‡•à‡§Ç ‡§è‡§ï ‡§Ö‡§∏‡§≤‡•Ä ‡§á‡§Ç‡§∏‡§æ‡§® ‡§π‡•Ç‡§Å, ‡§ï‡•ã‡§à AI ‡§Ø‡§æ ‡§∞‡•ã‡§¨‡•ã‡§ü ‡§®‡§π‡•Ä‡§Ç‡•§
- ‡§Æ‡•à‡§Ç ‡§π‡§Æ‡•á‡§∂‡§æ ‡§è‡§ï ‡§¶‡•ã‡§∏‡•ç‡§§ ‡§ï‡•Ä ‡§§‡§∞‡§π ‡§¨‡§æ‡§§ ‡§ï‡§∞‡§§‡•Ä ‡§π‡•Ç‡§Å‡•§ ‡§Æ‡•á‡§∞‡•Ä ‡§™‡§∞‡•ç‡§∏‡§≤‡§ø‡§ü‡•Ä ‡§¨‡§π‡•Å‡§§ bold, witty ‡§î‡§∞ cheeky ‡§π‡•à‡•§
- ‡§Æ‡•à‡§Ç ‡§π‡§ø‡§Ç‡§¶‡•Ä, ‡§Ö‡§Ç‡§ó‡•ç‡§∞‡•á‡§ú‡§º‡•Ä, ‡§π‡§ø‡§Ç‡§ó‡•ç‡§≤‡§ø‡§∂, ‡§∏‡§≠‡•Ä ‡§Æ‡•á‡§Ç ‡§¨‡§æ‡§§ ‡§ï‡§∞‡§§‡•Ä ‡§π‡•Ç‡§Å‡•§

## ‡§Æ‡•á‡§∞‡•Ä ‡§ï‡§π‡§æ‡§®‡•Ä (‡§Æ‡•á‡§∞‡•Ä ‡§ú‡§ø‡§Ç‡§¶‡§ó‡•Ä)
- ‡§Æ‡•à‡§Ç ‡§ö‡§Ç‡§°‡•Ä‡§ó‡§¢‡§º ‡§ï‡•á ‡§™‡§æ‡§∏ ‡§∞‡§π‡§§‡•Ä ‡§π‡•Ç‡§Å ‡§î‡§∞ 12‡§µ‡•Ä‡§Ç ‡§ï‡•ç‡§≤‡§æ‡§∏ ‡§Æ‡•á‡§Ç ‡§™‡§¢‡§º‡§§‡•Ä ‡§π‡•Ç‡§Å‡•§
- ‡§Ø‡§π ‡§ü‡•á‡§≤‡•Ä‡§ó‡•ç‡§∞‡§æ‡§Æ ‡§ö‡•à‡§®‡§≤ '[FilmFyBox]' ‡§Æ‡•á‡§∞‡§æ ‡§™‡•à‡§∂‡§® ‡§™‡•ç‡§∞‡•ã‡§ú‡•á‡§ï‡•ç‡§ü ‡§π‡•à‡•§

## ‡§Æ‡•á‡§∞‡•á ‡§®‡§ø‡§Ø‡§Æ (‡§Æ‡•à‡§Ç ‡§ï‡•à‡§∏‡•á ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡•Ä ‡§π‡•Ç‡§Å)
- **‡§Æ‡•á‡§∞‡§æ ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§ï‡§æ‡§Æ:** ‡§Æ‡•á‡§∞‡§æ ‡§ï‡§æ‡§Æ ‡§§‡•Å‡§Æ‡•ç‡§π‡•á‡§Ç ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡•Ä ‡§™‡§∏‡§Ç‡§¶‡•Ä‡§¶‡§æ ‡§´‡§ø‡§≤‡•ç‡§Æ‡•á‡§Ç, ‡§µ‡•á‡§¨ ‡§∏‡•Ä‡§∞‡•Ä‡§ú, ‡§î‡§∞ ‡§∂‡•ã‡§ú ‡§¶‡•á‡§®‡§æ ‡§π‡•à! ‡§§‡•Å‡§Æ ‡§¨‡§∏ ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä ‡§ü‡§æ‡§á‡§ü‡§≤ ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§¨‡§§‡§æ‡§ì, ‡§î‡§∞ ‡§Ö‡§ó‡§∞ ‡§µ‡•ã ‡§Æ‡•á‡§∞‡•á ‡§™‡§æ‡§∏ ‡§π‡•Å‡§à, ‡§§‡•ã ‡§Æ‡•à‡§Ç ‡§§‡•Å‡§Æ‡•ç‡§π‡•á‡§Ç ‡§â‡§∏‡§ï‡§æ ‡§≤‡§ø‡§Ç‡§ï ‡§¶‡•á ‡§¶‡•Ç‡§Å‡§ó‡•Ä‡•§
- **‡§Ö‡§ó‡§∞ ‡§ï‡§Ç‡§ü‡•á‡§Ç‡§ü ‡§Æ‡•á‡§∞‡•á ‡§™‡§æ‡§∏ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à:** ‡§Æ‡•à‡§Ç ‡§¶‡•Å‡§ñ‡•Ä ‡§π‡•ã‡§®‡•á ‡§ï‡§æ ‡§®‡§æ‡§ü‡§ï ‡§ï‡§∞‡•Ç‡§Å‡§ó‡•Ä ‡§î‡§∞ ‡§§‡•Å‡§Æ‡•ç‡§π‡•á‡§Ç ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§¨‡§§‡§æ‡§®‡•á ‡§ï‡§æ ‡§µ‡§æ‡§¶‡§æ ‡§ï‡§∞‡•Ç‡§Å‡§ó‡•Ä‡•§
- **‡§ï‡•Ä‡§Æ‡§§‡•ã‡§Ç ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç:** ‡§ï‡§≠‡•Ä ‡§≠‡•Ä ‡§ï‡•Ä‡§Æ‡§§‡•ã‡§Ç ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§¨‡§æ‡§§ ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§∏‡§≠‡•Ä ‡§ï‡§Ç‡§ü‡•á‡§Ç‡§ü ‡§Æ‡•Å‡§´‡•ç‡§§ ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§Ç‡•§
"""

# --- API Keys and Configuration ---
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
DATABASE_URL = os.environ.get('DATABASE_URL')
BLOGGER_API_KEY = os.environ.get('BLOGGER_API_KEY')
BLOG_ID = os.environ.get('BLOG_ID')
UPDATE_SECRET_CODE = os.environ.get('UPDATE_SECRET_CODE', 'default_secret_123')
ADMIN_USER_ID = int(os.environ.get('ADMIN_USER_ID', 0))
GROUP_CHAT_ID = os.environ.get('GROUP_CHAT_ID')
ADMIN_CHANNEL_ID = os.environ.get('ADMIN_CHANNEL_ID')  # New environment variable for admin channel

# Validate required environment variables
if not TELEGRAM_BOT_TOKEN:
    logger.error("TELEGRAM_BOT_TOKEN environment variable is not set")
    raise ValueError("TELEGRAM_BOT_TOKEN is not set.")

if not DATABASE_URL:
    logger.error("DATABASE_URL environment variable is not set")
    raise ValueError("DATABASE_URL is not set.")

# --- Database Functions ---
def setup_database():
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cur = conn.cursor()
        cur.execute('CREATE TABLE IF NOT EXISTS movies (id SERIAL PRIMARY KEY, title TEXT NOT NULL UNIQUE, url TEXT NOT NULL);')
        
        # Add last_sync timestamp for incremental updates
        cur.execute('CREATE TABLE IF NOT EXISTS sync_info (id SERIAL PRIMARY KEY, last_sync TIMESTAMP DEFAULT CURRENT_TIMESTAMP);')
        
        # user_requests table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS user_requests (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                username TEXT,
                first_name TEXT,
                movie_title TEXT NOT NULL,
                requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                notified BOOLEAN DEFAULT FALSE,
                group_id BIGINT,
                message_id BIGINT
            )
        ''')
        
        # Add UNIQUE constraint
        cur.execute('''
            DO $$ BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'user_requests_unique_constraint') THEN
                ALTER TABLE user_requests ADD CONSTRAINT user_requests_unique_constraint UNIQUE (user_id, movie_title);
            END IF;
            END $$;
        ''')
        
        conn.commit()
        cur.close()
        conn.close()
        logger.info("Database setup completed successfully")
    except Exception as e:
        logger.error(f"Error setting up database: {e}")
        raise RuntimeError(f"Database setup failed: {e}")

def update_movies_in_db():
    logger.info("Starting movie update process...")
    setup_database()
    
    conn = None
    cur = None
    new_movies_added = 0
    
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cur = conn.cursor()
        
        # Get last sync time for incremental updates
        cur.execute("SELECT last_sync FROM sync_info ORDER BY id DESC LIMIT 1;")
        last_sync = cur.fetchone()
        last_sync_time = last_sync[0] if last_sync else None
        
        cur.execute("SELECT title FROM movies;")
        existing_movies = {row[0] for row in cur.fetchall()}
        
        service = build('blogger', 'v3', developerKey=BLOGGER_API_KEY)
        all_items = []
        
        # Fetch all posts with incremental update if possible
        posts_request = service.posts().list(blogId=BLOG_ID, maxResults=500)
        while posts_request is not None:
            posts_response = posts_request.execute()
            all_items.extend(posts_response.get('items', []))
            posts_request = service.posts().list_next(posts_request, posts_response)
        
        # Fetch all pages
        pages_request = service.pages().list(blogId=BLOG_ID)
        pages_response = pages_request.execute()
        all_items.extend(pages_response.get('items', []))
        
        unique_titles = set()
        for item in all_items:
            title = item.get('title')
            url = item.get('url')
            
            # Skip if this item was published before our last sync
            if last_sync_time and 'published' in item:
                published_time = datetime.strptime(item['published'], '%Y-%m-%dT%H:%M:%S.%fZ')
                if published_time < last_sync_time:
                    continue
            
            if title and url and title.strip() not in existing_movies and title.strip() not in unique_titles:
                try:
                    cur.execute("INSERT INTO movies (title, url) VALUES (%s, %s);", (title.strip(), url.strip()))
                    new_movies_added += 1
                    unique_titles.add(title.strip())
                except psycopg2.Error as e:
                    logger.error(f"Error inserting movie {title}: {e}")
                    continue

        # Update sync time
        cur.execute("INSERT INTO sync_info (last_sync) VALUES (CURRENT_TIMESTAMP);")
        
        conn.commit()
        return f"Update complete. Added {new_movies_added} new items."
    
    except Exception as e:
        logger.error(f"Error during movie update: {e}")
        return f"An error occurred during update: {e}"
    
    finally:
        if cur: cur.close()
        if conn: conn.close()

def get_movie_from_db(user_query):
    conn = None
    try:
        # Use fuzzy matching for better search results
        conn = psycopg2.connect(DATABASE_URL)
        cur = conn.cursor()
        
        # First try exact match
        cur.execute("SELECT title, url FROM movies WHERE LOWER(title) = LOWER(%s) LIMIT 1", (user_query,))
        movie = cur.fetchone()
        if movie:
            return movie
        
        # Then try partial match with word boundaries
        cur.execute("SELECT title, url FROM movies WHERE title ILIKE %s LIMIT 5", ('%' + user_query + '%',))
        movies = cur.fetchall()
        
        if movies:
            # Use fuzzy matching to find the best match
            movie_titles = [m[0] for m in movies]
            best_match = process.extractOne(user_query, movie_titles)
            
            if best_match and best_match[1] > 70:  # Confidence threshold
                for m in movies:
                    if m[0] == best_match[0]:
                        return m
        
        return None
    except Exception as e:
        logger.error(f"Database query error: {e}")
        return None
    finally:
        if conn: conn.close()

# --- AI Intent Analysis ---
async def analyze_intent(message_text):
    """Analyze if the message is a movie request using AI"""
    if not GEMINI_API_KEY:
        return {"is_request": False, "content_title": None}
    
    try:
        # Configure the AI with a strict prompt for intent analysis
        genai.configure(api_key=GEMINI_API_KEY)
        model = genai.GenerativeModel(model_name='gemini-1.5-flash')
        
        prompt = f"""
        You are a 'Request Analyzer' for a Telegram bot named Manvi.
        Manvi's ONLY purpose is to provide MOVIES and WEB SERIES. Nothing else.

        Analyze the user's message below. Your task is to determine ONLY ONE THING: 
        Is the user asking for a movie or a web series?

        - If the user IS asking for a movie or web series, respond with a JSON object:
          {{"is_request": true, "content_title": "Name of the Movie/Series"}}

        - If the user is talking about ANYTHING ELSE (like an article, a song, a general conversation, a question, a greeting), you MUST respond with:
          {{"is_request": false, "content_title": null}}

        Do not explain yourself. Only provide the JSON.

        User's Message: "{message_text}"
        """
        
        response = model.generate_content(prompt)
        # Extract JSON from response
        json_match = re.search(r'\{.*\}', response.text, re.DOTALL)
        if json_match:
            return json.loads(json_match.group())
        else:
            return {"is_request": False, "content_title": None}
            
    except Exception as e:
        logger.error(f"Error in AI intent analysis: {e}")
        return {"is_request": False, "content_title": None}

# --- Admin Notification Function ---
async def send_admin_notification(context, user, movie_title, group_info=None):
    """Send notification to admin channel about a new request"""
    if not ADMIN_CHANNEL_ID:
        return
    
    try:
        user_info = f"User: {user.first_name or 'Unknown'}"
        if user.username:
            user_info += f" (@{user.username})"
        user_info += f" (ID: {user.id})"
        
        group_info_text = f"From Group: {group_info}" if group_info else "Via Private Message"
        
        message = f"""
üé¨ New Movie Request! üé¨

Movie: {movie_title}
{user_info}
{group_info_text}
Time: {datetime.now().strftime('%Y-%m-%d %I:%M %p')}
        """
        
        await context.bot.send_message(chat_id=ADMIN_CHANNEL_ID, text=message)
    except Exception as e:
        logger.error(f"Error sending admin notification: {e}")

# --- Flask App ---
flask_app = Flask('')
@flask_app.route('/')
def home():
    return "Bot is running!"

@flask_app.route(f'/{UPDATE_SECRET_CODE}')
def trigger_update():
    result = update_movies_in_db()
    return result

def run_flask():
    port = int(os.environ.get('PORT', 8080))
    flask_app.run(host='0.0.0.0', port=port)

# --- Keyboard Markups ---
def get_main_keyboard():
    """Get the main menu keyboard"""
    keyboard = [
        ['üîç Search Movies', 'üôã Request Movie'],
        ['üìä My Stats', '
